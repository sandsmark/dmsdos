# help file for dmsdos configuration
# idea shamelessly stolen from Linux kernel 

# Format of this file: description<nl>variable<nl>helptext<nl><nl>.
# If the question being documented is of type "choice", we list
# only the first occurring config variable. The help texts
# must not contain empty lines. No variable should occur twice; if it
# does, only the first occurrence will be used by Configure. The lines
# in a help text should be indented two positions. Lines starting with
# #' are ignored. To be nice to menuconfig, limit your lines to 70
# characters.

Detailed DMSDOS configuration (expert mode)
DMSDOS_EXPERT
  Say Y if you want a detailed setup (then a lot of things that you 
  may not be familiar with unless you are a dmsdos expert will be 
  asked). If you say N most dmsdos internal values are set to safe
  defaults which should be sufficient for most systems. (Yes, you
  _can_ change everything. But you'll have to understand what you do.)

Dos 6.0-6.22/Win95 Doublespace/Drivespace
DMSDOS_CONFIG_DBLSP_DRVSP
  Say Y if you want support for this kind of CVFs. This kind of CVF
  format is built into MSDOS 6.0-6.22 and older versions of Win95.
  If unsure, saying Y won't hurt except making the module larger.

Win95 Drivespace 3
DMSDOS_CONFIG_DRVSP3
  Say Y if you want support for this kind of CVFs. Note that
  Drivespace 3 has been sold seperately from Win95 for some time, but
  newer versions of Win95 seem to have Drivespace 3 built in.
  The software should tell its version number in the Help/Info menu
  under Win95. If unsure, saying Y won't hurt except making the module
  larger.

Stacker version 3
DMSDOS_CONFIG_STAC3
  Say Y if you want support for this kind of CVFs. If unsure, saying Y
  won't hurt except making the module larger.

Stacker version 4
DMSDOS_CONFIG_STAC4
  Say Y if you want support for this kind of CVFs. If unsure, saying Y
  won't hurt except making the module larger.

Use vmalloc instead of kmalloc
USE_VMALLOC
  The kernel knows to memory allocation interfaces - kmalloc and 
  vmalloc. kmalloc is faster but more likely to fail (i.e. claim that 
  the system is out of memory) - vmalloc very rarely fails but memory 
  is swappable and it is surely not a good idea to swap the cluster 
  cache to the disk... 
  If you have a system with lots of physical RAM you might want to 
  try kmalloc for better performance. vmalloc is always the safe 
  solution. If you are not sure, say Y, which is always safe. YOU ARE 
  STRONLY ENCOURAGED TO ENABLE VMALLOC WHEN DEBUGGING NEW CODE.

Advanced memory allocation
USE_XMALLOC
  Enables optimized memory allocation routine - it decides itself 
  whether to use kmalloc or vmalloc depending on the requested size 
  and on what the system can provide. 
  WARNING: this does not work for all kernels. It is known to work
  for 2.0.xx kernels. But I've got reports about problems with some 
  2.1.XX kernels and xmalloc. Maybe it also fails under 2.2.x. If 
  you get a message (maybe even a kernel panic) saying "please 
  disable XMALLOC" it is broken under your kernel.
  You may receive *lots* of "Couldn't get a free page" messages in 
  the syslog which can be safely ignored - they result from the 
  driver's memory allocation strategy. 
  DON'T USE XMALLOC WHEN DEBUGGING NEW CODE.
  Say N to feel safe.

Size of daemon cache
LISTSIZE
  Maximum number of clusters that can be delayed for compression -
  this is for the dmsdos compression daemon, not for write-back 
  caching. A value larger than 4096 seems to slow down your system 
  more than not using the daemon since the driver is busy with 
  maintaining the cache most of the time. Still good performance: 
  1024, which is also the recommended value.

Idle acache timeout
MAX_CACHE_TIME
  Time (in seconds) after which idle MDFAT/DFAT/BITFAT buffers are 
  returned to the kernel. Default is 60. (This time has only an effect 
  if the dmsdos daemon is running.)

Max MDFAT cache size
MDFATCACHESIZE
  mdfat cache sizes -- please note that these number of fs buffers are
  *permanently* held in memory - keep small on systems that are short 
  on memory. Default value: 40 (i.e. 20KB), which represents the MDFAT
  space needed for approx. 5000 clusters (4000 on drivespace 3), i.e.
  40MB (or 160MB on 32K clusters) of compressed data. 

Max DFAT cache size
DFATCACHESIZE
  dfat cache sizes -- please note that these number of fs buffers are
  *permanently* held in memory - keep small on systems that are short 
  on memory. Default value: 20 (i.e. 10KB), which represents the DFAT
  space for approx. 5000 clusters, i.e. 40MB (160MB on 32K clusters)
  of compressed data.

Max BITFAT cache size
BITFATCACHESIZE
  bitfat cache sizes -- please note that these number of fs buffers 
  are *permanently* held in memory - keep small on systems that are 
  short on memory. Default value: 10 (i.e. 5KB), which represents the
  BITFAT size for 400000 (200000 on stacker 4) compressed sectors,
  i.e. 200MB (100MB on stacker 4) of compressed data.

Enable write access
DBL_WRITEACCESS
  Say Y to compile in low-level write access code. If you say N all 
  low-level write access is replaced by an error written to syslog.
  Say N if you want to build a read-only dmsdos module.

Default loglevel
DEFAULT_LOGLEVEL
  Bit-coded field for debug messages (expert use only). Usually set 
  this to 0. Please read the documentation before changing this value.
  The log level can also be changed at run time via dutil (see manpage)
  or with a mount option.

Default compression level
DEFAULT_CF
  Select between:
     0=least efficient but fastest compression
     11=most efficient but slowest compression
  For slow processors you may want to use a lower value.
  The compression level can be changed at run time with dutil (see 
  manpage) or with a mount option. If you are unsure say 11.

Cluster cache size
CCACHESIZE
  Sets the maximum number of clusters dmsdos can keep in its cluster 
  cache. Keep small on systems with low memory - otherwise dmsdos may 
  eat up too much memory and slow down your system by causing great 
  swapping.
  Every cluster uses 8KB (32KB on drivespace 3 and sometimes on 
  Stacker 4). You shouldn't exceed approx. 1/4 of your physical RAM, 
  so use 64 if you have only 4MB or if you have only 16MB and you are 
  using drivespace 3. 
  WARNINGS: 
  1. If this value is too low, applications using files on a 
  compressed partition lock out each other. If it is much too low, 
  they may even lock out themselves and thus lock up the whole system. 
  Values below 64 are supposed critical, values below 32 are 
  supposed dangerous. 
  2. You might cause a system lockup also if you use more cache than
  you have physical RAM.

Idle cluster cache timeout
MAX_CCACHE_TIME
  Time in seconds after which unused clusters are removed from the 
  cluster cache. Default is 240. (This time has only an effect if the 
  dmsdos daemon is running.)

Maximum number of blocks to read ahead
MAX_READA
  Maximum number of sectors to read-ahead at once - default is 64 in 
  order to let a 32KB cluster fit in. This parameter has only an 
  effect if read-ahead is enabled in the speedup tricks & hacks section
  below.

Enable advanced read-ahead
USE_READA_LIST
  Use experimental (faster) read-ahead code in order to bypass 
  wait_on_buffer. If you say N the standard (slower) kernel read-ahead 
  code is used. Usually say Y unless you encounter strange problems.
  This option only has an effect if read-ahead is turned on in the
  speedup tricks & hacks section below.

Size of read-ahead list
READA_LIST_SIZE
  Fine-tune advanced read-ahead code. I always set this to 256. I 
  don't know whether changing this value really speeds up something 
  - my own benchmarks didn't lead to a clear result.
  This option has only an effect if read-ahead is turned on and 
  advanced read-ahead is enabled.

Read-ahead threshold
READA_THRESHOLD
  Read-ahead is only done when more than this amount of bytes are read 
  at once. This prevents a badly written program from issuing thousands 
  of useless read-aheads. 4095 is a good value since this allows 
  read-ahead just for a memory page (mmap gets the data in 4096 byte 
  blocks and should have a gain from read-ahead). Lower values may 
  cause clustersize/(value+1)-1 useless read-aheads per cluster.
  This option has only an effect if read-ahead is turned on in the
  speedup tricks & hacks section below.

Leave directories uncompressed
SP_BIT0
  Speedup Bit#0: avoids compression of directories. If it is set, 
  dmsdos never compresses directories for drivespace 3 and stacker 
  (others don't support compressed directories at all). Note that
  directories are accessed very often and otherwise had to be
  decompressed and compressed again after each access. Say Y.

Leave umsdos EMD file uncompressed
SP_BIT1
  Speedup Bit#1 is for umsdos upon dmsdos. If set, the driver never 
  compress the --linux-.--- special file (it contains extended 
  directory information). Setting this bit is strongly recommended.
  The special file is even more often written than a directory
  since it contains the access times (the directory contains only
  the modification times). You will regret compressing this file,
  even if you own the fastest computer of the world. Say Y.

Skip exact search on BITFAT allocation
SP_BIT2
  Speedup Bit#2: controls the free sector searching algorithm. If set,
  dmsdos searchs faster but less carefully for free space in the CVF
  at the cost of more fragmentation (this is *not* FAT level, but an
  internal lower level and very awful fragmentation). If you say Y,
  write access on large CVFs is faster (sometimes really notably
  faster). Be warned, a CVF that is too fragmented will be set to 
  read-only, so you will have to boot Dos from time to time and run 
  the CVF maintainance tools over it. Usually say N, but saying Y
  is not dangerous and may make you happier when writing much to a
  CVF.

Fast unmount
SP_BIT3
  Speedup Bit#3: speeds up CVF unmount. If set, the driver writes dirty
  clusters that are in the cache immediately without compressing them 
  before when the filesystem is to be unmounted. This way the unmount
  procedure will be quite fast. In contrast, if you say N the clusters
  are compressed before. Note that compression may take some time and
  thus blocks the system until it is ready. Since most people who 
  haven't read these lines tend to press the reset button when a 
  filesystem unmount takes somewhat longer (especially on a shutdown
  or reboot), the default is Y. If you can tolerate the time to wait
  and you are prepared to wait, say N.

Enable write-back cluster caching (instead of write-through)
SP_BIT4
  Speedup Bit#4 enables write-back cluster caching. If this bit is set
  the data in the cluster cache that have been changed by an 
  application and have to be written back to disk are not written
  back immediately - they are kept some time in memory just in order
  to save disk access when the application again changes the data.
  This usually causes a significant speedup for write access, 
  especially because dmsdos also delays compression and free space 
  allocation in that case. To be honest, there's a small risk of data
  loss if the system happens to crash before the data are written 
  back - but since your operating system is Linux a crash is rather 
  unlikely :) So say Y.

Enable read-ahead
SP_BIT5
  Speedup Bit#5 enables cluster read-ahead in general. If you say Y, 
  this causes the driver to initiate a low-level disk access for some 
  data when it thinks they are most likely needed in a short time 
  later. This usually speeds up read access a little. The trick is 
  that the driver doesn't wait for the read-ahead disk access 
  to finish. So the disk can position its head (and so on) while the 
  system can do something else. Most likely the disk access has 
  finished when the data are actually needed - this saves some time 
  we otherwise had to wait. Well, at least this is the nice idea 
  of read-ahead. However, since read-ahead relies on a prediction, 
  there may be situations when it is useless or even a loss.
  Just say Y.

Fast BITFAT allocation
SP_BIT6
  Speedup Bit#6 controls the free sector searching algorithm similar
  to Speedup Bit#2, but in a more drastic way (it simply switches it
  off). If this bit is set, free space allocation is very fast but 
  does not care about avoiding fragmentation at all. This is not
  recommended. BE WARNED, it can cause *much* fragmentation in very 
  short time. The "filesystem almost full" warning is suppressed.
  This switch is meant as a last resort if you cannot tolerate
  system slowdowns at all. Don't fill the compressed filesystem
  up to more than 3/4 when this switch is set. Write access may 
  fail horribly and cause data loss due to too high fragmentation.
  (Well, this is Dos/Win95 strategy - never tell the disadvantages)
  Usually say N. If unsure about the dangers, say N also. Only say Y
  if you really know what you are doing.

Use daemon if present
SP_BIT7
  Speedup Bit#7 controls what jobs the dmsdos daemon has to do (if it
  is running). If set, the daemon takes over all the compression of 
  data that have to be written to disk. This can make your system 
  respond a little faster on write access as compression will be 
  mostly done when the system is idle. This is recommended for systems
  usually running at high processor load, or in general for slow 
  processors. In contrast, if you say N the daemon is just used for
  dmsdos internal memory management. If unsure, say Y.

Avoid fragmented writes
SP_BIT8
  Speedup Bit#8 controls what to do when the filesystem is too
  fragmented for normal write access. Usually all data for one cluster
  are stored in contiguous sectors, but if the filesystem is too 
  fragmented there may not be a 'free hole' that is large enough for
  the data. Speedup Bit#8 controls what to do in that case. If this 
  bit is set dmsdos just returns a 'no space left on device' error and
  refuses to write to the CVF any more.
  Drivespace 3 and Stacker know a hack for that situation: they allow
  storing the data of one cluster in several fragments on the disk.
  If the bit is clear, the driver tries to write the data in several
  fragments. Be warned, this makes future filesystem access slower as
  it needs more disk head movements to read fragmented clusters.
  *** Note that for Stacker this is currently not implemented ***
  The default answer is N.

Use internal daemon
INTERNAL_DAEMON
  Dmsdos can start a daemon that does delayed compression in the 
  background when the system is idle. It also reduces dmsdos memory
  consumption when the driver has nothing to do for a long time.
  The daemon exists in two variants: One is a user-level program and
  the other one is a kernel process. The user-level program is called
  "external daemon" while the other is the "internal daemon".
  When the internal daemon is used, the external one won't run.
  The internal daemon compresses faster (because the data needn't be 
  copied from kernel space to user space and back), but seems to eat 
  up much system time - use it only on *really fast* machines. Also, 
  it is started automatically by the system when it is needed (and 
  killed when it is no longer needed). On the other hand, the external 
  daemon eats up minimal system time and ressources, but must be 
  started and killed by hand. 
  *** If you have a fast processor and lots of memory (_real RAM_)
  you probably don't need any dmsdos daemon at all.
  Say N if unsure.

Internal daemon wakeup time
IDMSDOSD_TIME
  Time interval in seconds for internal daemon - it awakes 
  periodically and looks for data to compress or memory to free up
  in this interval. Set it to 30 if you are unsure. This option has 
  only an effect if the internal compression daemon is used.

Disable logging completely
NOLOG
  Say Y if you need a really small module - this leaves out the 
  logging messages from the object code of the module. You cannot 
  use a loglevel other than 0 in this case. Usually say N.
  Especially say N when debugging.

Sequence number logging
SEQLOG
  Say Y to generate a sequence number for each log line. The numbers
  are guaranteed to be uniqe and in order of call. This is for 
  debugging in order to be sure no messages have been lost (There seem 
  to be some black holes in syslog that eat messages when they occur 
  massively.)
  Say N if you are not debugging. If you find that messages are lost,
  change the #define LOG_BUF_LEN to at least 65536 in file
  linux/kernel/printk.c and recompile your kernel. Please note that 
  the LOG_BUF_LEN value is expected to be a power of 2 by the Linux 
  kernel code.

Writable mmap support
DMSDOS_USE_READPAGE
  Say Y to use the standard readpage interface (for writable mmap).
  Say N to use old mmap interface which is read-only. Say Y except
  you run into strange problems with writable mmaps.
  WARNING: Old mmap interface is broken in dmsdos under some newer 
  2.1.xx and 2.2.x kernels (it doesn't compile). It may be removed 
  from dmsdos some day.
